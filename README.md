# ADR 2.0 — Core Concepts

ADR 2.0 is a modern evolution of Architecture Decision Records designed for AI-assisted software development.
It extends traditional ADRs by introducing **automation**, **agent integration**, and **machine-verifiable rules**, enabling teams to maintain architectural consistency with minimal manual effort.

---

## 1. Purpose

ADR 2.0 preserves architectural decisions in a way that:

* aligns with modern AI-assisted workflows,
* reduces documentation overhead,
* increases architectural integrity through continuous validation,
* and integrates seamlessly into repository-local development.

---

## 2. Document Types

### 2.1 AAR (Agent Analysis Record)

AARs are natural-language design reasoning files generated by AI agents or developers.

Characteristics:

* High-level conceptual reasoning
* Explains **why** a change was made
* Does **not** include code or diffs
* Stored anywhere under `docs/`, except `docs/adr/`
* Serves as raw material for ADR creation

---

### 2.2 ADR (Architecture Decision Record)

A formal, machine-readable decision document.

Characteristics:

* Stored only in `docs/adr/`
* Created automatically from AARs
* Reviewed through PRs
* Defines long-term architectural constraints
* Contains **Validation Rules** that CI can enforce

---

## 3. ADR 2.0 Structure

```
# Title
# Status
(Proposed | Accepted | Deprecated | Superseded)

# Context
Background, problem, constraints.

# Decision
The architectural decision made.

# Rationale
Why this decision was chosen (trade-offs & reasoning).

# Alternatives Considered
Options evaluated and why they were rejected.

# Consequences
Positive/negative outcomes of the decision.

# Validation Rules
Declarative technical constraints for CI enforcement.
```

---

## 4. Workflows in ADR 2.0

### 4.1 AAR Creation

AI agent hooks capture reasoning during development sessions and store AARs automatically.

### 4.2 ADR Promotion

CI or an automated agent determines whether an AAR includes an architectural decision and generates an ADR draft.

### 4.3 Human Review

Engineers review the generated ADR via PR, ensuring accuracy and team alignment.

### 4.4 Continuous Enforcement

ADR Validation Rules are enforced on every PR, preventing architectural drift.

---

## 5. Benefits of ADR 2.0

* Reduces the need for manual documentation
* Captures implicit agent reasoning
* Ensures architecture remains consistent over time
* Prevents violations through automated validation
* Works independently in each repository
* Reflects real-world design decisions made collaboratively with AI

---

## 6. Philosophy

ADR 2.0 accepts that:

* Most modern design reasoning originates from AI-assisted workflows.
* Architectural decisions must be captured with minimal friction.
* Documentation should flow naturally from development, not the other way around.
* Architecture governance must be automated to remain relevant.

ADR 2.0 is the natural evolution of architecture documentation in an AI-native development environment.

---

## 7. ADR 2.0 자동화(GitHub Actions)

이 리포지토리는 AAR → ADR 승격을 에이전트 친화적으로 자동화합니다.

### 작동 방식
- 워크플로: `.github/workflows/adr-generator.yml`
- 트리거: `docs/**` 변경 또는 `workflow_dispatch`
- 단계:
  1. `docs/` 하위 AAR(`docs/adr/` 제외)을 스캔해 ADR 후보 감지(프롬프트: `adr-candidate-detect-prompt.md`).
  2. ADR 생성(프롬프트: `adr-generate-prompt.md`, 규칙 추출: `validate-rule-prompt.md`).
  3. `docs/adr/ADR-XXXX-<slug>.md`로 저장하며 YAML 프런트매터에 `id/status/scope/created_at/source/decision/related/validation_rules/agent_playbook/index_terms` 포함.
  4. `docs/adr/index.json`을 생성/갱신하여 에이전트 검색용 메타데이터 제공.
  5. ADR로 승격된 AAR과 ADR 후보가 아니라고 판정된 AAR은 정리 차원에서 삭제.

### 필요한 설정
- 레포지토리 Secrets: `OPENAI_API_KEY`
- 선택: 레포지토리 Variables `OPENAI_MODEL`(기본 `gpt-5.1`)

### 로컬 실행(선택)
- 의존성 설치: `pip install -r requirements.txt`
- 실행:
  ```bash
  export OPENAI_API_KEY=...
  # (선택) export OPENAI_MODEL=gpt-5.1
  python scripts/adr2_agent_action.py
  ```
- 출력: `docs/adr/ADR-XXXX-*.md`와 `docs/adr/index.json` 생성/갱신
  - `index.json`은 토큰 절약을 위해 요약 메타데이터만 포함(id/title/status/scope/path/related/index_terms/decision_summary/source)

### ADR 출력 형태(에이전트 지향)
- YAML 프런트매터: `id/status/scope/created_at/source/decision/related/validation_rules/agent_playbook/index_terms`
- 본문 섹션: Decision, Context, Rationale, Alternatives, Consequences, Validation Rules, Agent Playbook(에이전트 강제/감지/시정 지침), Retrieval Hints

## GitHub Action (Marketplace)

### Summary
- Name: ADR 2.0 Agent Promotion
- Purpose: detect AARs under `docs/`, promote to ADRs under `docs/adr/ADR-XXXX-*.md`, update `docs/adr/index.json`, and clean up processed AARs
- Features: agent-friendly template (Agent Playbook, Validation Rules), slim index, progress logs, automatic AAR cleanup

### Inputs
- `openai_api_key` (required): OpenAI API key
- `openai_model` (optional, default `gpt-5.1`): model name

### Permissions
```yaml
permissions:
  contents: write
```

### Example workflow (`.github/workflows/adr.yaml`)
```yaml
name: ADR 2.0 Agent Promotion
on:
  workflow_dispatch:
  push:
    paths:
      - "docs/**"

permissions:
  contents: write

jobs:
  adr:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: p2achAI/adr-agent@v1  # pin tag/commit
        with:
          openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          openai_model: gpt-5.1
```

### Flow
1) Scan `docs/` (skip `docs/adr/`) → detect candidates  
2) Generate ADRs (`docs/adr/ADR-XXXX-<slug>.md` with front matter `id/status/scope/created_at/source/decision/related/validation_rules/agent_playbook/index_terms`)  
3) Update slim `docs/adr/index.json` (with `decision_summary`)  
4) Delete promoted AARs and non-candidates  

### Environment
- `ADR2_REPO_ROOT` is auto-set to `github.workspace` so the action runs against the calling repo.

### Caution
- AAR source files are deleted after processing; back them up elsewhere if you need to keep originals.
